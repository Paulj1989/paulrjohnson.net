{
  "hash": "dd01612198d99ae7c95c5e3ed5196463",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Automating Netlify Redirects Using Lua\nsubtitle: |\n    How to generate Netlify redirects for a Quarto website using a Lua script.\ndescription-meta: |\n    A deep dive into the Lua programming language and how it can be used to\n    automatically generate redirects for blog posts and categories in a Quarto\n    website.\ndate: 2025-06-01\nimage: traffic.webp\nimage-alt: |\n    A slightly worn 'Diverted Traffic' road sign leaning against a black bollard\n    on the pavement beside the road.\ncategories: [Netlify, Quarto, Web Development, Lua]\n---\n\nLast year, I wrote a [blog post](/blog/setting-up-netlify-redirects-with-quarto) about my process for generating Netlify redirects. It was a similar process to that used by many others, adapted slightly to work with my slightly different setup. It involved housing a couple chunks of code in the homepage (`index.qmd` in the root directory) that would generate redirects every time the homepage is rendered.\n\nThis worked fine. It got the job done. However, it bothered me that I had to remember to re-render the homepage every time I needed to update the redirects file. This relied too heavily on my remembering to do something. So, I've finally had a crack at fixing this and setting something up that will run without my intervention.\n\nI've set up a Lua script that is called before the whole project is rendered. I figured a brief post outlining what I've done and how it works might be helpful to others trying to figure this out, and it should be relatively easy to adapt to your own needs.\n\n## The Old (Manual-ish) Setup\n\nI won't spend too long going over the old approach (you can find it in the [blog post](/blog/setting-up-netlify-redirects-with-quarto) I wrote last year). It worked, and I never actually forgot to re-render the homepage to update the redirects. However, I didn't love having to go through that extra step, and I certainly didn't trust myself to remember this detail.\n\nCreating dependencies is an unnecessary mess when all I want to do is generate some redirects from a relatively simple website structure.\n\n## The Automated Solution\n\nInstead, I wrote a [Lua](https://www.lua.org) script[^AI] that is set to run before any Quarto document renders (using Quarto's [pre/post rendering functionality](https://quarto.org/docs/projects/scripts.html#pre-and-post-render)), which generates all my redirects in a file that is stored at the root for Netlify to pick up and use in deployment.\n\nIt's essentially the same process I followed before. Still, by shifting it into a separate script that runs when Netlify renders the site (using the Quarto Netlify plugin), I no longer have to worry about running this before pushing a new post.\n\nI chose Lua because it is already packaged up in Quarto's installation, as Pandoc uses Lua as its filter language, and Netlify recognises it when deploying the site. That means no extra work is required with a Lua script. Lua is relatively simple, and if you have experience with R and/or Python, it shouldn't take long to pick it up[^Resources].\n\nThere are three types of redirects handled by this script:\n\n- Manual Redirects - These are hand-written rules stored in a `_manualredirects` file, intended to redirect old pages when the website used a different structure.\n- Blog Post Redirects - Automatically generated rules that redirect from simple URLs (`/blog/my-post-title`) to the full dated URLs (`/blog/2025-05-26-my-post-title`).\n- Category Redirects - Dynamic redirects that map tag-style URLs (`/tags/lua`) to filtered blog views (`/blog/#category=lua`).\n\n[^AI]:\n\nFull disclosure: I put together the script with help from Claude AI, as I had no prior experience with Lua. I'm not claiming to have written this from scratch, but I still wanted to share it, as it may be valuable to others.\n\n[^Resources]:\n\nIf you need to learn Lua, I recommend the [Learn Lua in 15 Minutes](https://learnxinyminutes.com/lua/) resource, as well as the [Lua Cheatsheet](https://quarto.org/docs/extensions/luarefv51.pdf).\n\n## Redirects Using Lua\n\nIf you want to skip the details, here is the script in full.\n\n<details>\n<summary>Lua Code (Click to Expand)</summary>\n\n```lua\n-- build/redirects.lua\n-- Generates redirects for blog posts and categories\nlocal system = require(\"pandoc.system\")\n\n-- Toggle for debug output\nlocal DEBUG = false\n\nif not os.getenv(\"QUARTO_PROJECT_RENDER_ALL\") then\n    print(\"Skipping redirects...\")\n    os.exit()\nend\n\nlocal function debug_log(message)\n    if DEBUG then\n        io.stderr:write(\"[Redirects Debug] \" .. message .. \"\\n\")\n    end\nend\n\nlocal function is_dir(path)\n    local handle = io.popen('[ -d \"' .. path ..\n        '\" ] && echo \"yes\" || echo \"no\"')\n    local result = handle:read(\"*a\"):gsub(\"%s+\", \"\")\n    handle:close()\n    return result == \"yes\"\nend\n\nlocal function file_exists(path)\n    local file = io.open(path, \"r\")\n    if file then\n        file:close()\n        return true\n    end\n    return false\nend\n\nlocal function read_lines(file_path)\n    debug_log(\"Attempting to read: \" .. file_path)\n    if not file_exists(file_path) then\n        debug_log(\"File not found: \" .. file_path)\n        return {}\n    end\n\n    local lines = {}\n    local file = io.open(file_path, \"r\")\n    for line in file:lines() do\n        table.insert(lines, line)\n    end\n    file:close()\n    debug_log(\"Read \" .. #lines .. \" lines from: \" .. file_path)\n    return lines\nend\n\nlocal function extract_categories(post_path)\n    local qmd_path = post_path .. \"/index.qmd\"\n    if not file_exists(qmd_path) then\n        debug_log(\"Blog post .qmd not found: \" .. qmd_path)\n        return {}\n    end\n\n    local content = read_lines(qmd_path)\n    local categories = {}\n\n    for _, line in ipairs(content) do\n        local cat_match = line:match(\"^categories:%s*%[(.+)%]\")\n        if cat_match then\n            for cat in cat_match:gmatch(\"([^,]+)\") do\n                cat = cat:gsub(\"^%s*(.-)%s*$\", \"%1\") -- Trim whitespace\n                table.insert(categories, cat)\n            end\n            break\n        end\n    end\n    return categories\nend\n\nlocal function load_manual_redirects(project_root)\n    local manual_paths = {\n        project_root .. \"/assets/_manualredirects\",\n        project_root .. \"/build/_manualredirects\"\n    }\n\n    for _, path in ipairs(manual_paths) do\n        if file_exists(path) then\n            debug_log(\"Found manual redirects at: \" .. path)\n            return read_lines(path)\n        end\n    end\n    return {}\nend\n\nlocal function process_blog_posts(blog_dir)\n    debug_log(\"Looking for blog posts in: \" .. blog_dir)\n\n    local redirects = {}\n    local blog_posts = {}\n    local all_categories = {}\n\n    local dir_cmd = 'find \"' .. blog_dir ..\n        '\" -maxdepth 1 -mindepth 1 -type d'\n    debug_log(\"Running directory listing command: \" .. dir_cmd)\n\n    local handle = io.popen(dir_cmd)\n    for post_path in handle:lines() do\n        local post_name = post_path:match(\"([^/]+)$\")\n        debug_log(\"Found potential blog post: \" ..\n            (post_name or \"unnamed\"))\n\n        -- Process only directories matching date pattern\n        if post_name and post_name:match(\"^%d%d%d%d%-%d%d%-%d%d%-\") then\n            local title_slug = post_name:gsub(\"^%d%d%d%d%-%d%d%-%d%d%-\", \"\")\n            local old = \"/blog/\" .. title_slug\n            local new = \"/blog/\" .. post_name\n\n            table.insert(redirects, old .. \" \" .. new)\n            table.insert(blog_posts, post_path)\n            debug_log(\"Added redirect: \" .. old .. \" â†’ \" .. new)\n\n            -- Collect categories\n            local post_categories = extract_categories(post_path)\n            for _, cat in ipairs(post_categories) do\n                debug_log(\"Found category: \" .. cat)\n                all_categories[cat] = true\n            end\n        end\n    end\n    handle:close()\n\n    return redirects, blog_posts, all_categories\nend\n\nlocal function generate_category_redirects(all_categories)\n    local redirects = {}\n    local category_count = 0\n\n    debug_log(\"Generating category redirects\")\n    for category, _ in pairs(all_categories) do\n        local encoded_category = category:gsub(\" \", \"%%20\")\n        local tag = category:lower():gsub(\" \", \"-\")\n        table.insert(redirects, \"/tags/\" .. tag .. \" \" ..\n            \"/blog/#category=\" .. encoded_category)\n        debug_log(\"Added category redirect: /tags/\" .. tag)\n        category_count = category_count + 1\n    end\n\n    return redirects, category_count\nend\n\nlocal function write_redirects_file(project_root, redirects)\n    local out_file = project_root .. \"/_redirects\"\n    debug_log(\"Writing redirects to: \" .. out_file)\n\n    local f = io.open(out_file, \"w\")\n    if f then\n        for _, line in ipairs(redirects) do\n            f:write(line .. \"\\n\")\n        end\n        f:close()\n        debug_log(\"Successfully wrote \" .. #redirects .. \" redirects\")\n        return true\n    else\n        io.stderr:write(\"ERROR: Could not open output file for writing: \" ..\n            out_file .. \"\\n\")\n        return false\n    end\nend\n\nfunction Pandoc(doc)\n    debug_log(\"Starting redirect generation...\")\n\n    local project_root = system.get_working_directory()\n    debug_log(\"Working directory: \" .. project_root)\n\n    -- Check Netlify environment (preserved for potential future use)\n    local netlify_build_dir = os.getenv(\"NETLIFY\") and\n        os.getenv(\"NETLIFY_BUILD_BASE\")\n    if netlify_build_dir then\n        debug_log(\"Running in Netlify environment: \" .. netlify_build_dir)\n    end\n\n    local blog_dir = project_root .. \"/blog\"\n    debug_log(\"Blog directory path: \" .. blog_dir)\n\n    if not is_dir(blog_dir) then\n        debug_log(\"Blog directory not found, skipping redirect generation\")\n        return doc\n    end\n\n    -- Load manual redirects\n    local manual_redirects = load_manual_redirects(project_root)\n    debug_log(\"Added \" .. #manual_redirects .. \" manual redirects\")\n\n    -- Process blog posts\n    local post_redirects, blog_posts, all_categories =\n        process_blog_posts(blog_dir)\n\n    -- Generate category redirects\n    local category_redirects, category_count =\n        generate_category_redirects(all_categories)\n\n    -- Combine all redirects\n    local all_redirects = {}\n    for _, redirect in ipairs(manual_redirects) do\n        table.insert(all_redirects, redirect)\n    end\n    for _, redirect in ipairs(post_redirects) do\n        table.insert(all_redirects, redirect)\n    end\n    for _, redirect in ipairs(category_redirects) do\n        table.insert(all_redirects, redirect)\n    end\n\n    -- Write redirects file\n    if write_redirects_file(project_root, all_redirects) then\n        debug_log(\"Redirect generation complete\")\n        print(\"Redirects written to _redirects (\" ..\n            #all_redirects ..\n            \" entries, \" ..\n            #blog_posts .. \" posts, \" .. #manual_redirects ..\n            \" manual, \" .. category_count .. \" categories)\")\n    end\n\n    return doc\nend\n```\n</details>\n\n### Key Components\n\nFor anyone interested in how the script works, however, here are some details.\n\n#### Environment Detection\n\n```lua\nlocal project_root = system.get_working_directory()\nlocal netlify_build_dir = os.getenv(\"NETLIFY\") and os.getenv(\"NETLIFY_BUILD_BASE\")\n```\n\nThe script first determines where it's running - locally during development or on Netlify during deployment. This flexibility ensures it works in both environments.\n\n#### File System Operations\n\nLua provides basic file system operations, which the script uses:\n\n- Directory checking - Verifying that blog directories exist.\n- File reading - Processing blog post metadata and manual redirect files.\n- File writing - Creating the final `_redirects` file[^Structure].\n\n[^Structure]:\n\nMy manual redirects file is located in the `build` folder, but if yours (or your redirects script) is stored elsewhere, you will need to update this accordingly.\n\n#### Pattern Matching\n\nOne of Lua's strengths is its pattern-matching system. The script uses this to find my blog posts based on the pattern of ISO dates at the start of a blog post folder.\n\n```lua\nif post_name and post_name:match(\"^%d%d%d%d%-%d%d%-%d%d%-\") then\n    local title_slug = post_name:gsub(\"^%d%d%d%d%-%d%d%-%d%d%-\", \"\")\n```\n\nThis finds blog posts with names like `2025-05-26-my-post-title` and extracts just the title part. If you use a different structure for your posts, you will need to adjust this accordingly.\n\n#### Category Processing\n\nThe script reads each blog post's metadata to extract categories.\n\n```lua\nlocal cat_match = line:match(\"^categories:%s*%[(.+)%]\")\n```\n\nThis looks for lines like `categories: [Netlify, Quarto, Web Development, Lua]` in the blog post's YAML header.\n\n## Wrapping Up\n\nNow, every time I publish a new blog post or add categories, the redirects are automatically updated without any manual intervention. This process also runs every time I render the entire site[^Skip]. This might be overkill. I could probably set it up to only run when it detects a fresh deployment to Netlify, but this feels like a good way to spot any issues or errors and will make debugging a little easier.\n\nThere isn't that much to what I've done, but I figured it was worth sharing because others might like to do something similar. It shouldn't require significant editing, but it will involve adjusting to fit the structure of your website. Hopefully, this is of value to at least one other person!\n\n[^Skip]:\n\n    One of the first steps in the script checks if the entire site is rendering:\n\n    ```{lua}\n    if not os.getenv(\"QUARTO_PROJECT_RENDER_ALL\") then\n        print(\"Skipping redirects...\")\n        os.exit()\n    end\n    ```\n\n    If the command being called is `quarto render`, then the redirects process runs in full. However, if it is `quarto preview` or a specific page is being rendered, it skips.\n\n## Acknowledgments {.appendix}\n\nPreview image by [Dagny Reese](https://unsplash.com/@dagny_2020) on [Unsplash](https://unsplash.com/photos/black-and-yellow-no-smoking-sign-G9l9ejbuHlI).\n\n## Support {.appendix}\n\nIf you enjoyed this blog post and would like to support my work, you can [buy me a coffee or a beer or give me a tip](https://www.buymeacoffee.com/paulj1989) as a thank you.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}